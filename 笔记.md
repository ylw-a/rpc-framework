1. 客户端发起注册
   1. 服务注册接口
   2. 服务发现接口
   3. 临时服务心跳接口
   4. 持久服务主动检测接口
   5. 服务下线接口
   6. 服务变更接口
2. 服务端发现记录服务
   1. 监控服务健康状态
   2. ...
3. 服务端配置中心添加配置
4. 客户端启动时读取配置
   1. bootstrap之后，application之前
5. 集群模式

Spring Boot starter module for gRPC framework.
   View on GitHub地址：https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/server/getting-started.html


1. 启动参数
-Dos.detected.classifier=windows-x86_64

# 服务端注册接口
服务注册接口

1. 获取命名空间

2. 获取服务名称

3. 检查服务名称，符合分组名+服务名的规范

4. 获取入参

5. 进行服务注册

   1. 入参校验

   2. 获取clientId

   3. 获取客户端

      1. 如果不存在，则获取客户端属性后注册到客户端管理器中
      2. 如果存在，则直接注册到客户端管理器

   4. 获取服务对象，创建持久对象或者是临时对象

   5. 进行服务注册

      1. ClientOperationServiceProxy，初级入口，还没有真正开始注册服务

      2. 先进行选择，是使用持久化的注册Servicer还是临时的注册Service

      3. 如果是临时的话：

         ```mermaid
         flowchart TD
             A[开始] --> B[验证实例合法性]
             B --> C[获取服务单例]
             C --> D{服务是否为临时服务?}
             D -->|否| E[抛出异常]
             D -->|是| F[获取客户端]
             F --> G[检查客户端合法性]
             G --> H[生成实例发布信息]
             H --> I[添加实例到客户端]
             I --> J[更新客户端时间戳]
             J --> K[更新客户端修订版本]
             K --> L[发布客户端注册事件]
             L --> M[发布实例元数据事件]
             M --> N[结束]
         
         ```

         观察者模式：

         ```java
         package com.framework.server;
         
         import java.util.ArrayList;
         import java.util.List;
         
         // 主题接口
         interface Subject {
             void registerObserver(Observer observer);
             void removeObserver(Observer observer);
             void notifyObservers(Event event);
         }
         
         // 观察者接口
         interface Observer {
             void onEvent(Event event);
         }
         
         // 事件接口
         interface Event {
             String getMessage();
         }
         
         // 具体主题
         class ConcreteSubject implements Subject {
             private final List<Observer> observers = new ArrayList<>();
         
             @Override
             public void registerObserver(Observer observer) {
                 observers.add(observer);
             }
         
             @Override
             public void removeObserver(Observer observer) {
                 observers.remove(observer);
             }
         
             @Override
             public void notifyObservers(Event event) {
                 for (Observer observer : observers) {
                     observer.onEvent(event);
                 }
             }
         
             public void publishEvent(Event event) {
                 notifyObservers(event);
             }
         }
         
         // 具体观察者
         class ConcreteObserver implements Observer {
             @Override
             public void onEvent(Event event) {
                 System.out.println("Received event: " + event.getMessage());
             }
         }
         
         class TwoObserver implements Observer {
         
             @Override
             public void onEvent(Event event) {
                 System.out.println("这是第二个观察者：msg：=》" + event.getMessage());
             }
         }
         
         class ThreeObserver implements Observer {
         
             @Override
             public void onEvent(Event event) {
                 System.out.println("这是第三个观察者，msg=》" + event.getMessage());
             }
         }
         
         // 具体事件
         class ConcreteEvent implements Event {
             private String message;
         
             public ConcreteEvent(String message) {
                 this.message = message;
             }
         
             @Override
             public String getMessage() {
                 return message;
             }
         }
         
         // 测试
         class ObserverPatternExample {
             public static void main(String[] args) {
                 // 定义主题
                 ConcreteSubject subject = new ConcreteSubject();
         
                 // 定义观察者
                 Observer observer = new ConcreteObserver();
         
                 // 注册观察者
                 subject.registerObserver(observer);
         
                 System.out.println("第一次发布。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。");
         
                 // 事件发布，原理就是，观察者注册到主题后，主题会在发布事件的时候挨个遍历所有观察者，并调用观察者的事件执行方法
                 subject.publishEvent(new ConcreteEvent("Hello, Observer Pattern!"));
         
                 TwoObserver twoObserver = new TwoObserver();
                 System.out.println("移除第一个观察者并加入第二个");
                 subject.registerObserver(twoObserver);
                 subject.removeObserver(observer);
         
                 System.out.println("第二次发布。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。");
                 subject.publishEvent(new ConcreteEvent("哈哈哈"));
         
                 ThreeObserver threeObserver = new ThreeObserver();
                 System.out.println("加入第三个");
                 subject.registerObserver(threeObserver);
         
                 System.out.println("第三次发布。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。");
                 subject.publishEvent(new ConcreteEvent("嘿嘿嘿"));
             }
         }
         
         ```